// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Helper APIs used by this extension

import * as fs from 'fs';
import * as child_process from 'child_process';
import * as logger from './logger';
import * as make from './make';
import * as path from 'path';
import * as vscode from 'vscode';

// C/CPP standard versions
export type StandardVersion = 'c89' | 'c99' | 'c11' | 'c17' | 'c++98' | 'c++03' | 'c++11' | 'c++14' | 'c++17' | 'c++20' | 'c++23' |
                              'gnu89' | 'gnu99' | 'gnu11' | 'gnu17' | 'gnu++98' | 'gnu++03' | 'gnu++11' | 'gnu++14' | 'gnu++17' | 'gnu++20' | 'gnu++23'
                              undefined;

// Supported target architectures (for code generated by the compiler)
export type TargetArchitecture = 'x86' | 'x64' | 'arm' | 'arm64' | undefined;

// IntelliSense modes
export type IntelliSenseMode = "msvc-x64" | "msvc-x86" | "msvc-arm" | "msvc-arm64" |
                               "gcc-x64" | "gcc-x86" | "gcc-arm" | "gcc-arm64" |
                               "clang-x64" | "clang-x86" | "clang-arm" | "clang-arm64" | undefined;

// Language types
export type Language = "c" | "cpp" | undefined;

export function checkFileExistsSync(filePath: string): boolean {
    try {
        return fs.statSync(filePath).isFile();
    } catch (e) {
    }
    return false;
}

export function checkDirectoryExistsSync(directoryPath: string): boolean {
    try {
        return fs.statSync(directoryPath).isDirectory();
    } catch (e) {
    }
    return false;
}

export function createDirectorySync(directoryPath: string): boolean {
    try {
        fs.mkdirSync(directoryPath, { recursive: true });
        return true;
    } catch {
    }
    return false;
}

export function deleteFileSync(filePath: string): void {
    try {
        fs.unlinkSync(filePath);
    } catch (e) {
    }
}

export function readFile(filePath: string): string | undefined {
    try {
        if (checkFileExistsSync(filePath)) {
            return fs.readFileSync(filePath).toString();
        }
    } catch (e) {
    }

    return undefined;
}

export function writeFile(filePath: string, content: string): string | undefined {
    try {
        fs.writeFileSync(filePath, content);
    } catch (e) {
    }

    return undefined;
}

// Get the platform-specific temporary directory
export function tmpDir(): string {
    if (process.platform === 'win32') {
        return process.env['TEMP'] || "";
    } else {
        return '/tmp';
    }
}

// Returns the full path to a temporary script generated by the extension
// and used to parse any additional compiler switches that need to be sent to CppTools.
export function parseCompilerArgsScriptFile(): string {
    let scriptFile: string = path.join(tmpDir(), "parseCompilerArgs");

    if (process.platform === "win32") {
        scriptFile += ".bat";
    } else {
        scriptFile += ".sh";
    }

    return scriptFile;
}

export function getWorkspaceRoot(): string {
    return vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri.fsPath : "";
}

 // Evaluate whether a string looks like a path or not,
// without using fs.stat, since dry-run may output tools
// that are not found yet at certain locations,
// without running the prep targets that would copy them there
export function looksLikePath(pathStr: string): boolean {
    // TODO: to be implemented
    return true;
}

// Evaluate whether the tool is invoked from the current directory
export function pathIsCurrentDirectory(pathStr: string): boolean {
    // Ignore any spaces or tabs before the invocation
    pathStr = pathStr.trimLeft();

    if (pathStr === "") {
        return true;
    }

    if (process.platform === "win32" && process.env.MSYSTEM === undefined) {
        if (pathStr === ".\\") {
            return true;
        }
    } else {
        if (pathStr === "./") {
            return true;
        }
    }

    return false;
}

// Helper that searches for a tool in all the paths forming the PATH environment variable
// Returns the first one found or undefined if not found.
// TODO: implement a variation of this helper that scans on disk for the tools installed,
// to help when VSCode is not launched from the proper environment
export function toolPathInEnv(name: string): string | undefined {
    let envPath: string | undefined = process.env["PATH"];
    let envPathSplit: string[] = [];
    if (envPath) {
        envPathSplit = envPath.split(path.delimiter);
    }

    // todo: if the compiler is not found in path, scan on disk and point the user to all the options
    // (the concept of kit for cmake extension)

    return envPathSplit.find(p => {
        let fullPath: string = path.join(p, path.basename(name));
        // Often a path is added by the user to the PATH environment variable with surrounding quotes,
        // especially on Windows where they get automatically added after TAB.
        // These quotes become inner (not surrounding) quotes after we append various file names or do oher processing,
        // making file sysem stats fail. Safe to remove here.
        fullPath = removeQuotes(fullPath);
        if (checkFileExistsSync(fullPath)) {
            return fullPath;
        }
    });
}

function taskKill(pid: number): Promise<void> {
    return new Promise<void>((resolve, reject) => {
        child_process.exec(`taskkill /pid ${pid} /T /F`, (error) => {
            if (error) {
                reject(error);
            } else {
                resolve();
            }
        });
    });
}

export async function killTree(progress: vscode.Progress<{}>, pid: number): Promise<void> {
    if (process.platform === 'win32') {
        try {
            await taskKill(pid);
        } catch (e) {
            logger.message(`Failed to kill process ${pid}: ${e}`);
        }
        return;
    }

    let children: number[] = [];
    let stdoutStr: string = "";

    let stdout: any = (result: string): void => {
        stdoutStr += result;
    };

    try {
        // pgrep should run on english, regardless of the system setting.
        const result: SpawnProcessResult = await spawnChildProcess('pgrep', ['-P', pid.toString()], getWorkspaceRoot(), true, false, stdout);
        if (!!stdoutStr.length) {
            children = stdoutStr.split('\n').map((line: string) => Number.parseInt(line));

            logger.message(`Found children subprocesses: ${stdoutStr}.`);
            for (const other of children) {
                if (other) {
                    await killTree(progress, other);
                }
            }
        }
    } catch (e) {
        logger.message(e.message);
        throw e;
    }

    try {
        logger.message(`Killing process PID = ${pid}`);
        progress.report({ increment: 1, message: `Terminating process PID=${pid} ...` });
        process.kill(pid, 'SIGINT');
    } catch (e) {
        if (e.code !== 'ESRCH') {
            throw e;
        }
    }
}

// Environment variables helpers (inspired from CMake Tools utils).
export interface EnvironmentVariables { [key: string]: string; }

export function normalizeEnvironmentVarname(varname: string): string {
    return process.platform === 'win32' ? varname.toUpperCase() : varname;
}

export function mergeEnvironment(...env: EnvironmentVariables[]): EnvironmentVariables {
    return env.reduce((acc, vars) => {
        if (process.platform === 'win32') {
            // Env vars on windows are case insensitive, so we take the ones from
            // active env and overwrite the ones in our current process env
            const norm_vars: EnvironmentVariables = Object.getOwnPropertyNames(vars).reduce<EnvironmentVariables>((acc2, key: string) => {
                acc2[normalizeEnvironmentVarname(key)] = vars[key];
                return acc2;
            }, {});
            return {...acc, ...norm_vars};
        } else {
            return {...acc, ...vars};
        }
    }, {});
}

export interface SpawnProcessResult {
    returnCode: number;
    signal: string;
}

// Helper to spawn a child process, hooked to callbacks that are processing stdout/stderr
// forceEnglish is true when the caller relies on parsing english words from the output.
export function spawnChildProcess(
    processName: string,
    args: string[],
    workingDirectory: string,
    forceEnglish: boolean,
    ensureQuoted: boolean,
    stdoutCallback?: (stdout: string) => void,
    stderrCallback?: (stderr: string) => void): Promise<SpawnProcessResult> {

    const localeOverride: EnvironmentVariables = {
        LANG: "C",
        LC_ALL: "C"
    };

    // Use english language for this process regardless of the system setting.
    const environment: EnvironmentVariables = (forceEnglish) ? localeOverride : {};
    const finalEnvironment: EnvironmentVariables = mergeEnvironment(process.env as EnvironmentVariables, environment);

    return new Promise<SpawnProcessResult>((resolve, reject) => {
        // Honor the "terminal.integrated.automationShell.<platform>" setting.
        // According to documentation (and settings.json schema), the three allowed values for <platform> are "windows", "linux" and "osx".
        // child_process.SpawnOptions accepts a string (which can be read from the above setting) or the boolean true to let VSCode pick a default
        // based on where it is running.
        let shellType: string | undefined;
        let shellPlatform: string = (process.platform === "win32") ? "windows" : (process.platform === "linux") ? "linux" : "osx";
        let workspaceConfiguration: vscode.WorkspaceConfiguration = vscode.workspace.getConfiguration("terminal");
        shellType = workspaceConfiguration.get<string>(`integrated.automationProfile.${shellPlatform}`) || // automationShell is deprecated
                    workspaceConfiguration.get<string>(`integrated.automationShell.${shellPlatform}`); // and replaced with automationProfile

        // Final quoting decisions for process name and args before being executed.
        let qProcessName: string = ensureQuoted ? quoteStringIfNeeded(processName) : processName;
        let qArgs: string[] = ensureQuoted ? args.map(arg => {
            return quoteStringIfNeeded(arg);
        }) : args;

        if (ensureQuoted) {
           logger.message(`Spawning child process with:\n process name: ${qProcessName}\n process args: ${qArgs}\n working directory: ${workingDirectory}\n shell type: ${shellType || "default"}`, "Debug");
        }

        const child: child_process.ChildProcess = child_process.spawn(qProcessName, qArgs,
                                                                      { cwd: workingDirectory, shell: shellType || true, env: finalEnvironment });
        make.setCurPID(child.pid);

        if (stdoutCallback) {
            child.stdout.on('data', (data) => {
                stdoutCallback(`${data}`);
            });
        }

        if (stderrCallback) {
            child.stderr.on('data', (data) => {
                stderrCallback(`${data}`);
            });
        }

        child.on('close', (returnCode: number, signal: string) => {
            resolve({returnCode, signal});
        });

        child.on('exit', (returnCode: number) => {
            resolve({returnCode, signal: ""});
        });

        if (child.pid === undefined) {
            reject(new Error(`Failed to spawn process: ${processName} ${args}`));
        }
    });
}

// Helper to eliminate empty items in an array
export function dropNulls<T>(items: (T | null | undefined)[]): T[] {
    return items.filter(item => (item !== null && item !== undefined)) as T[];
}

// Convert a posix path (/home/dir1/dir2/file.ext) into windows path,
// by calling the cygpah which comes installed with MSYS/MinGW environments
// and which is also aware of the drive under which /home/ is placed.
// result: c:\msys64\home\dir1\dir2\file.ext
// Called usually for Windows subsystems: MinGW, CygWin.
export async function cygpath(pathStr: string): Promise<string> {
   let windowsPath: string = pathStr;

   let stdout: any = (result: string): void => {
      windowsPath = result.replace(/\n/mg, ""); // remove the end of line
  };

  // Running cygpath can use the system locale.
  await spawnChildProcess("cygpath", [pathStr, "-w"], "", false, false, stdout);
  return windowsPath;
}

// Helper that transforms a posix path (used in various non windows environments on a windows system)
// into a windows style path.
export async function ensureWindowsPath(path: string): Promise<string> {
   if (process.platform !== "win32" || !path.startsWith("/")) {
      return path;
   }

   let winPath: string = path;

   if (process.env.MSYSTEM !== undefined) {
      // When in MSYS/MinGW/CygWin environments, cygpath can help transform into a windows path
      // that we know CppTools will use when querying us.
      winPath = await cygpath(winPath);
   } else {
      // Even in a pure windows environment, there are tools that may report posix paths.
      // Instead of searching a cygpath tool somewhere, do the most basic transformations:

      // Mount drives names like "cygdrive" or "mnt" can be ignored.
      const mountDrives: string[] = ["cygdrive", "mnt"];
      for (const drv of mountDrives) {
         if (winPath.startsWith(`/${drv}`)) {
            winPath = winPath.substr(drv.length + 1);

            // Exit the loop, because we don't want to remove anything else
            // in case the path happens to follow with a subfolder with the same name
            // as other mountable drives for various systems/environments.
            break;
         }
      }

      // Remove the slash and add the : for the drive.
      winPath = winPath.substr(1);
      const driveEndIndex: number = winPath.search("/");
      winPath = winPath.substring(0, driveEndIndex) + ":" + winPath.substr(driveEndIndex);

      // Replace / with \.
      winPath = winPath.replace(/\//mg, "\\");
   }

   return winPath;
}

// Helper to reinterpret one relative path (to the given current path) printed by make as full path
export async function makeFullPath(relPath: string, curPath: string | undefined): Promise<string> {
    let fullPath: string = relPath;

    if (!path.isAbsolute(fullPath) && curPath) {
        fullPath = path.join(curPath, relPath);
    }

    // For win32, ensure we have a windows style path.
    fullPath = await ensureWindowsPath(fullPath);

    return fullPath;
}

// Helper to reinterpret the relative paths (to the given current path) printed by make as full paths
export async function makeFullPaths(relPaths: string[], curPath: string | undefined): Promise<string[]> {
   let fullPaths: string[] = [];

   for (const p of relPaths) {
      let fullPath: string = await makeFullPath(p, curPath);
      fullPaths.push(fullPath);
   }

   return fullPaths;
}

// Helper to reinterpret one full path as relative to the given current path
export function makeRelPath(fullPath: string, curPath: string | undefined): string {
    let relPath: string = fullPath;

    if (path.isAbsolute(fullPath) && curPath) {
        relPath = path.relative(curPath, fullPath);
    }

    return relPath;
}

// Helper to reinterpret the relative paths (to the given current path) printed by make as full paths
export function makeRelPaths(fullPaths: string[], curPath: string | undefined): string[] {
    let relPaths: string[] = [];

    fullPaths.forEach(p => {
        relPaths.push(makeRelPath(p, curPath));
    });

    return fullPaths;
}

// Helper to remove any quotes(", ' or `) from a given string
// because many file operations don't work properly with paths
// having quotes in the middle.
const quotesStr: string[] = ["'", '"', "`"];
export function removeQuotes(str: string): string {
   for (const p in quotesStr) {
      if (str.includes(quotesStr[p])) {
         let regExpStr: string = `${quotesStr[p]}`;
         let regExp: RegExp = RegExp(regExpStr, 'g');
         str = str.replace(regExp, "");
    }
   }

    return str;
}

// Remove only the quotes (", ' or `) that are surrounding the given string.
export function removeSurroundingQuotes(str: string): string {
    let result: string = str.trim();
    for (const p in quotesStr) {
      if (result.startsWith(quotesStr[p]) && result.endsWith(quotesStr[p])) {
         result = result.substring(1, str.length - 1);
         return result;
     }
   }

    return str;
}

// Quote given string if it contains space and is not quoted already
export function quoteStringIfNeeded(str: string) : string {
   // No need to quote if there is no space or ampersand present.
   if (!str.includes(" ") && !str.includes("&")) {
      return str;
   }

   // Return if already quoted.
   for (const q in quotesStr) {
      if (str.startsWith(quotesStr[q]) && str.endsWith(quotesStr[q])) {
         return str;
      }
   }

   // Quote and return.
   return `"${str}"`;
}

// Used when constructing a regular expression from file names which can contain
// special characters (+, ", ...etc...).
const escapeChars: RegExp = /[\\\^\$\*\+\?\{\}\(\)\.\!\=\|\[\]\ \/]/;  // characters that should be escaped.
export function escapeString(str: string): string {
    let escapedString: string = "";
    for (const char of str) {
        if (char.match(escapeChars)) {
            escapedString += `\\${char}`;
        } else {
            escapedString += char;
        }
    }
    return escapedString;
}

export function elapsedTimeSince(start: number): number {
    // Real elapsed times not useful in testing mode and we want to avoid diffs.
    // We could alternatively disable the messages from being printed.
    return (process.env['MAKEFILE_TOOLS_TESTING'] === '1') ? 0 : (Date.now() - start) / 1000;
}

// Helper to evaluate whether two settings (objects or simple types) represent the same content.
// It recursively analyzes any inner subobjects and is also not affected
// by a different order of properties.
export function areEqual(setting1: any, setting2: any): boolean {
    if (setting1 === null || setting1 === undefined ||
        setting2 === null || setting2 === undefined) {
        return setting1 === setting2;
    }

    // This is simply type
    if (typeof (setting1) !== "function" && typeof (setting1) !== "object" &&
        typeof (setting2) !== "function" && typeof (setting2) !== "object") {
        return setting1 === setting2;
    }

    let properties1: string[] = Object.getOwnPropertyNames(setting1);
    let properties2: string[] = Object.getOwnPropertyNames(setting2);

    if (properties1.length !== properties2.length) {
        return false;
    }

    for (let p: number = 0; p < properties1.length; p++) {
        let property: string = properties1[p];
        let isEqual: boolean;
        if (typeof(setting1[property]) === 'object' && typeof(setting2[property]) === 'object') {
            isEqual = areEqual(setting1[property], setting2[property]);
        } else {
            isEqual = (setting1[property] === setting2[property]);
        }

        if (!isEqual) {
            return false;
        }
    }

    return true;
}

// Answers whether the given object has at least one property.
export function hasProperties(obj: any): boolean {
    if (obj === null || obj === undefined) {
        return false;
    }

    let props: string[] = Object.getOwnPropertyNames(obj);
    return props && props.length > 0;
}

// Apply any properties from source to destination, logging for overwrite.
// To make things simpler for the caller, create a valid dst if given null or undefined.
export function mergeProperties(dst: any, src: any): any {
    let props: string[] = src ? Object.getOwnPropertyNames(src) : [];
    props.forEach(prop => {
        if (!dst) {
            dst = {};
        }

        if (dst[prop] !== undefined) {
            logger.message(`Destination object already has property ${prop} set to ${dst[prop]}. Overwriting from source with ${src[prop]}`, "Debug");
        }

        dst[prop] = src[prop];
    });

    return dst;
}
export function removeDuplicates(src: string[]) : string[] {
    let seen: {[key: string]: boolean} = {};
    let result: string[] = [];
    src.forEach(item => {
        if (!seen[item]) {
            seen[item] = true;
            result.push(item);
        }
    });

    return result;
}

export function sortAndRemoveDuplicates(src: string[]) : string[] {
    return removeDuplicates(src.sort());
}

export function reportDryRunError(dryrunOutputFile: string): void {
    logger.message(`You can see the detailed dry-run output at ${dryrunOutputFile}`);
    logger.message("Make sure that the extension is invoking the same make command as in your development prompt environment.");
    logger.message("You may need to define or tweak a custom makefile configuration in settings via 'makefile.configurations' like described here: [link]");
    logger.message("Also make sure your code base does not have any known issues with the dry-run switches used by this extension (makefile.dryrunSwitches).");
    logger.message("If you are not able to fix the dry-run, open a GitHub issue in Makefile Tools repo: "
        + "https://github.com/microsoft/vscode-makefile-tools/issues");
}

// Helper to make paths absolute until the extension handles variables expansion.
export function resolvePathToRoot(relPath: string): string {
    if (!path.isAbsolute(relPath)) {
        return path.join(getWorkspaceRoot(), relPath);
    }

    return relPath;
}

// Helper for substituting workspace paths.
export function resolveSubstitutedPath(path: string): string {
    return path.replace(/^\${workspace(Folder|Root)}/, getWorkspaceRoot());
}

// Schedule a task to be run at some future time. This allows other pending tasks to
// execute ahead of the scheduled task and provides a form of async behavior for TypeScript.
export function scheduleTask<T>(task: () => T): Promise<T> {
    return new Promise<T>((resolve, reject) => {
        setImmediate(() => {
            try {
                const result: T = task();
                resolve(result);
            } catch (e) {
                reject(e);
            }
        });
    });
}

// Async version of scheduleTask
export async function scheduleAsyncTask<T>(task: () => Promise<T>): Promise<T> {
   return new Promise<T>((resolve, reject) => {
       setImmediate(async () => {
           try {
               const result: T = await task();
               resolve(result);
           } catch (e) {
               reject(e);
           }
       });
   });
}

export function thisExtension(): vscode.Extension<any> {
    const ext: vscode.Extension<any> | undefined = vscode.extensions.getExtension('ms-vscode.makefile-tools');
    if (!ext) {
      throw new Error("Our own extension is null.");
    }

    return ext;
}

export interface PackageJSON {
    name: string;
    publisher: string;
    version: string;
    contributes: any;
}

export function thisExtensionPackage(): PackageJSON {
    const pkg: PackageJSON = thisExtension().packageJSON as PackageJSON;

    return {
      name: pkg.name,
      publisher: pkg.publisher,
      version: pkg.version,
      contributes: pkg.contributes
    };
}

export function thisExtensionPath(): string { return thisExtension().extensionPath; }
